<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title><![CDATA[Tag: Java | 记往开来]]></title>
<link href="http://xiaoliuai.github.io/tags/java/atom.xml" rel="self"/>
<link href="http://xiaoliuai.github.io/"/>
<updated>2014-12-19T22:19:55+01:00</updated>
<id>http://xiaoliuai.github.io/</id>
<author>
<name><![CDATA[Xiao Liu]]></name>

</author>
<generator uri="http://octopress.org/">Octopress</generator>

<entry>
<title type="html"><![CDATA[Drill的Java后端]]></title>
<link href="http://xiaoliuai.github.io/blog/2014-12-18-drilljava.html"/>
<updated>2014-12-18T00:00:00+01:00</updated>
<id>http://xiaoliuai.github.io/blog/drilljava</id>
<content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 环境与配置加载</a>
<ul>
<li><a href="#sec-1-1">1.1. 配置文件</a></li>
<li><a href="#sec-1-2">1.2. 获取配置内容</a></li>
<li><a href="#sec-1-3">1.3. 根据配置进行渲染</a></li>
</ul>
</li>
<li><a href="#sec-2">2. 持久化</a></li>
<li><a href="#sec-3">3. 业务层</a>
<ul>
<li><a href="#sec-3-1">3.1. Controller</a></li>
<li><a href="#sec-3-2">3.2. Service</a></li>
</ul>
</li>
</ul>
</div>
</div>


<p>
Java后端负责业务逻辑,数据持久化(数据库),安全等等.目前接触到的内容有
账号注册登录管理,本地化设置等等.将整个后端当做一个应用,那么在主目录
下有一个 <code>Application.java</code> 类作为整个应用的入口.这个类最基本的应用需要
<code>@ComponentScan</code> 和 <code>@EnableAutoConfiguration</code> 两个标签来声明自动配
置和扫描组件;同时在 <code>main</code> 函数里实例化一个 <code>SpringApplication</code> 对象
并调用对象函数 <code>run()</code> 就行了. 目前的程序里还用
<code>app.setAdditionalProfiles</code> 在没有命令行参数的时候默认加载dev配置.
</p>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><a href="xiaoliuai.github.io/tags/java/atom.xml"><span class="section-number-2">1</span> 环境与配置加载</a></h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 配置文件</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<code>SpringApplication</code> 会自动搜索以下路径来寻找
<code>application.properties</code> 作为配置文件.
</p>
<ol class="org-ol">
<li>当前路径下地 <code>/config</code> 子文件夹
</li>
<li>当前路径
</li>
<li><code>classpath:/config</code>
</li>
<li><code>classpath</code>
</li>
</ol>
<p>
同时,SpringApplication还支持 <font
    color='blue'>YAML</font> 文件,即 <i>applicaiton.yml</i>.
函数 <code>SpringApplication.setAdditionalProfiles("dev")</code> 则会额外加载
<i>application-dev.yml</i> (或者 <i>application-dev.properties</i>), 而不是
<i>dev.yml</i>.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 获取配置内容</h3>
<div class="outline-text-3" id="text-1-2">
<p>
当我们有类继承了EnvironmentAware这个接口的时候,框架会自动调用这个类
的 <code>setEnvironment</code> 方法,将一个 <code>Environment</code> 对象交给这个类的对象
从而使这个类获得配置文件中提供的参数. <code>LocaleConfiguration</code> 和
<code>MailConfiguration</code> 两个类展示了相关的编程方法.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">public</span> <span style="color: #859900;">class</span> <span style="color: #268bd2;">MailConfiguration</span> <span style="color: #859900;">implements</span> <span style="color: #268bd2;">EnvironmentAware</span> {
    <span style="color: #859900;">public</span> <span style="color: #268bd2;">void</span> <span style="color: #b58900;">setEnvironment</span>(<span style="color: #268bd2;">Environment</span> <span style="color: #6c71c4;">environment</span>) {
        <span style="color: #859900;">this</span>.propertyResolver = <span style="color: #859900;">new</span> <span style="color: #268bd2;">RelaxedPropertyResolver</span>(environment, ENV_SPRING_MAIL);
    }
}
</pre>
</div>

<p>
另一种方法是直接 <code>@Inject</code> 一个 <code>Environment</code> 的对象.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">public</span> <span style="color: #859900;">class</span> <span style="color: #268bd2;">MailService</span> {
    <span style="color: #268bd2;">@Inject</span>
    <span style="color: #859900;">private</span> <span style="color: #268bd2;">Environment</span> <span style="color: #6c71c4;">env</span>;
}
</pre>
</div>
<p>
<b><font color='red'>&lt;&#x2013;这种方法跟之前所介绍的有什么区别,暂时不知道.&#x2013;&gt;</font></b>
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 根据配置进行渲染</h3>
<div class="outline-text-3" id="text-1-3">
<p>
<code>LocalResolver</code> 和 <code>Interceptor</code>. 在接受请求的时候, <code>Interceptor</code>
拦截请求中特定的参数值,并且调用 <code>LocalResolver</code> 的函数来进行相关渲
染处理.在 <code>LocaleConfiguration</code> 中,龙伟权通过定义Bean来指定特定的
<code>LocalResolver</code>, 即 <code>AngularCookieLocaleResolver</code>.
</p>

<p>
问题:
</p>
<ol class="org-ol">
<li><code>LocaleConfiguration</code> 和 <code>ThymeleafConfiguration</code> 都有方法返回
<code>MessageSource</code>, <code>MailService</code> 里面貌似引用的是
<code>LocaleConfiguration</code> 返回的对象,为什么?
</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 持久化</h2>
<div class="outline-text-2" id="text-2">
<p>
对象的关联问题.Mongodb本身作为NoSql的典范,内部以文件和类似json的数
据形式来储存数据.Mongodb中一个Document可以看做关系数据库中的一行数
据,一个Repository可以看做关系数据库中的一个表(table).目前我们有三个
标记为 <code>@Document</code> 的类 <code>PersistentToken,Task,User</code> 和对应的
<code>Repository</code> 类.
</p>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 业务层</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Controller</h3>
<div class="outline-text-3" id="text-3-1">
<p>
控制器类都在org.team.drill.web下面,统一以 <i>XXXResource</i> 命名.
</p>
<ul class="org-ul">
<li>registerAccount
<ul class="org-ul">
<li>check if login/email exist
</li>
<li>userService create user
</li>
<li>send activation mail
</li>
</ul>
</li>
<li>activateAccount
<ul class="org-ul">
<li><i>userService.activateRegistration</i> <span class="underline">get user by activation key</span>
</li>
</ul>
</li>
<li>isAuthenticate
<ul class="org-ul">
<li>HttpServletRequest request.getRemoteUser()
</li>
</ul>
</li>
<li>getAccount
<ul class="org-ul">
<li><i>userService.getUserWithAuthorities()</i> <span class="underline">get current user by SecurityUtils</span>
</li>
</ul>
</li>
<li>saveAccount
<ul class="org-ul">
<li>check email is not used by any user in repository(input)
</li>
<li>update account information <i>userService.updateUserInformation</i>
</li>
</ul>
</li>
<li>changePassword (newPassword)
<ul class="org-ul">
<li><i>userService.changePassword(newPassword)</i>
</li>
</ul>
</li>
<li>getCurrentSession
<ul class="org-ul">
<li>userRepository.findOne(SecurityUtils.getCurrentLogin())
</li>
<li>persistentTokenRepository.findByUser(user)
</li>
</ul>
</li>
<li>invalideSession
<ul class="org-ul">
<li>find current user SecurityUtils.getCurrentLogin()
</li>
<li>delete persistentToken
</li>
</ul>
</li>

<li>getUser
</li>
</ul>

<p>
不论是Service还是Resource,都是靠 <code>SecurityUtils.getCurrentLogin()</code>
来获取当前用户的.那么问题来了,SecurityUtils如何知道当前用户是谁?
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">public</span> <span style="color: #859900;">final</span> <span style="color: #859900;">class</span> <span style="color: #268bd2;">SecurityUtils</span> {

    <span style="color: #859900;">private</span> <span style="color: #b58900;">SecurityUtils</span>() {
    }

    <span style="color: #d33682;">/**</span>
<span style="color: #d33682;">     * Get the login of the current user.</span>
<span style="color: #d33682;">     */</span>
    <span style="color: #859900;">public</span> <span style="color: #859900;">static</span> <span style="color: #268bd2;">String</span> <span style="color: #b58900;">getCurrentLogin</span>() {
        <span style="color: #268bd2;">SecurityContext</span> <span style="color: #6c71c4;">securityContext</span> = SecurityContextHolder.getContext();
        <span style="color: #268bd2;">Authentication</span> <span style="color: #6c71c4;">authentication</span> = securityContext.getAuthentication();
        <span style="color: #268bd2;">UserDetails</span> <span style="color: #6c71c4;">springSecurityUser</span> = <span style="color: #268bd2;">null</span>;
        <span style="color: #268bd2;">String</span> <span style="color: #6c71c4;">userName</span> = <span style="color: #268bd2;">null</span>;

        <span style="color: #859900;">if</span>(authentication != <span style="color: #268bd2;">null</span>) {
            <span style="color: #859900;">if</span> (authentication.getPrincipal() <span style="color: #859900;">instanceof</span> UserDetails) {
                springSecurityUser = (<span style="color: #268bd2;">UserDetails</span>) authentication.getPrincipal();
                userName = springSecurityUser.getUsername();
            } <span style="color: #859900;">else</span> <span style="color: #859900;">if</span> (authentication.getPrincipal() <span style="color: #859900;">instanceof</span> String) {
                userName = (<span style="color: #268bd2;">String</span>) authentication.getPrincipal();
            }
        }

        <span style="color: #859900;">return</span> userName;
    }
}
</pre>
</div>
<p>
<code>SecurityContextHolder</code> 在文档里解释为&#8221;with the current execution
thread&#8221;. 那么该如何理解 <code>resource</code> <code>service</code> 的运行方式?一个,还是
多个对象对应不同的客户端?
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Service</h3>
</div>
</div>

]]></content>
</entry>

</feed>
