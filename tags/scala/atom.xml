<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title><![CDATA[Tag: Scala | 记往开来]]></title>
<link href="http://xiaoliuai.github.io/tags/scala/atom.xml" rel="self"/>
<link href="http://xiaoliuai.github.io/"/>
<updated>2016-01-20T18:36:47+01:00</updated>
<id>http://xiaoliuai.github.io/</id>
<author>
<name><![CDATA[Xiao Liu]]></name>

</author>
<generator uri="http://octopress.org/">Octopress</generator>

<entry>
<title type="html"><![CDATA[Akka]]></title>
<link href="http://xiaoliuai.github.io/blog/2015-03-13-akka.html"/>
<updated>2015-03-13T00:00:00+01:00</updated>
<id>http://xiaoliuai.github.io/blog/akka</id>
<content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Actors</a>
<ul>
<li><a href="#sec-1-1">1.1. Falt toleration</a></li>
<li><a href="#sec-1-2">1.2. Persistent Actor</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Cluster</a>
<ul>
<li><a href="#sec-2-1">2.1. Simple Cluster</a>
<ul>
<li><a href="#sec-2-1-1">2.1.1. Configuration</a></li>
<li><a href="#sec-2-1-2">2.1.2. Code</a></li>
<li><a href="#sec-2-1-3">2.1.3. Running</a></li>
</ul>
</li>
<li><a href="#sec-2-2">2.2. Dial-in example</a></li>
<li><a href="#sec-2-3">2.3. Cluster Aware Routers</a>
<ul>
<li><a href="#sec-2-3-1">2.3.1. <b>Group router</b></a></li>
<li><a href="#sec-2-3-2">2.3.2. <b>Pool router</b></a></li>
</ul>
</li>
<li><a href="#sec-2-4">2.4. Adaptive Load Balancing</a></li>
</ul>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><a href="xiaoliuai.github.io/tags/scala/atom.xml"><span class="section-number-2">1</span> Actors</a></h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">import</span> akka.<span style="color: #268bd2;">actor</span>.{ ActorRef, ActorSystem, Props, Actor, Inbox }&#57344;&#57345;&#57345;
<span style="color: #859900;">import</span> scala.concurrent.duration.<span style="color: #268bd2;">_</span>&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">Three messages, one is object, two are case classes</span>&#57344;&#57345;&#57345;
<span style="color: #859900;">case</span> object Greet&#57344;&#57345;&#57345;
<span style="color: #859900;">case</span> <span style="color: #859900;">class</span> WhoToGreet(who: String)&#57344;&#57345;&#57345;
<span style="color: #859900;">case</span> <span style="color: #859900;">class</span> Greeting(message: String)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
<span style="color: #859900;">class</span> Greeter <span style="color: #859900;">extends</span> <span style="color: #268bd2;">Actor</span> {&#57344;&#57345;&#57345;
  <span style="color: #268bd2;">var</span> <span style="color: #6c71c4;">greeting</span> = <span style="color: #2aa198;">""</span>&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  def receive = {&#57344;&#57345;&#57345;
    <span style="color: #859900;">case</span> WhoToGreet(who) =&gt; greeting = s<span style="color: #2aa198;">"hello, $who"</span>&#57344;&#57345;&#57345;
    <span style="color: #859900;">case</span> Greet           =&gt; sender <span style="color: #268bd2;">!</span> Greeting(greeting)&#57344;&#57345;&#57345;
    <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">Send the current greeting back to the sender</span>&#57344;&#57345;&#57345;
  }&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
<span style="color: #268bd2;">object</span> <span style="color: #6c71c4;">HelloAkkaScala</span> <span style="color: #859900;">extends</span> <span style="color: #268bd2;">App</span> {&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">Create the 'helloakka' actor system</span>&#57344;&#57345;&#57345;
  <span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">system</span> = ActorSystem(<span style="color: #2aa198;">"helloakka"</span>)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">Create the 'greeter' actor</span>&#57344;&#57345;&#57345;
  val greeter = system.actorOf(<span style="color: #268bd2;">Props</span>[Greeter], <span style="color: #2aa198;">"greeter"</span>)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">Create an "actor-in-a-box"</span>&#57344;&#57345;&#57345;
  val inbox = Inbox.create(system)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">Tell the 'greeter' to change its 'greeting' message</span>&#57344;&#57345;&#57345;
  greeter.tell(WhoToGreet(<span style="color: #2aa198;">"akka"</span>), ActorRef.noSender)&#57344;&#57345;&#57345;
  <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">Ask the 'greeter for the latest 'greeting'</span>&#57344;&#57345;&#57345;
  <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">Reply should go to the "actor-in-a-box"</span>&#57344;&#57345;&#57345;
  inbox.send(greeter, Greet)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">Wait 5 seconds for the reply with the 'greeting' message</span>&#57344;&#57345;&#57345;
  val Greeting(message1) = inbox.receive(5.seconds)&#57344;&#57345;&#57345;
  println(s<span style="color: #2aa198;">"Greeting: $message1"</span>)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">Change the greeting and ask for it again</span>&#57344;&#57345;&#57345;
  greeter.tell(WhoToGreet(<span style="color: #2aa198;">"typesafe"</span>), ActorRef.noSender)&#57344;&#57345;&#57345;
  inbox.send(greeter, Greet)&#57344;&#57345;&#57345;
  val Greeting(message2) = inbox.receive(5.seconds)&#57344;&#57345;&#57345;
  println(s<span style="color: #2aa198;">"Greeting: $message2"</span>)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  val greetPrinter = system.actorOf(<span style="color: #268bd2;">Props</span>[GreetPrinter])&#57344;&#57345;&#57345;
  <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">after zero seconds, send a Greet message every second to the greeter with a sender of the greetPrinter</span>&#57344;&#57345;
  system.scheduler.schedule(0.seconds, 1.second, greeter, Greet)(system.dispatcher, greetPrinter)&#57344;&#57345;
&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">prints a greeting</span>&#57344;&#57345;&#57345;
<span style="color: #859900;">class</span> <span style="color: #268bd2;">GreetPrinter</span> <span style="color: #859900;">extends</span> <span style="color: #268bd2;">Actor</span> {&#57344;&#57345;&#57345;
  <span style="color: #268bd2;">def</span> <span style="color: #6c71c4;">receive</span> = {&#57344;&#57345;&#57345;
    <span style="color: #859900;">case</span> Greeting(message) =&gt; println(message)&#57344;&#57345;&#57345;
  }&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
</pre>
</div>

<ul class="org-ul">
<li>Sending messages
<ol class="org-ol">
<li><code>actor ! message</code> or <code>actor.tell(message, sender)</code>.
</li>
<li><code>inbox.send(sender, message)</code>
</li>
<li><code>system.scheduler.schedule(initDelay, interval, receiver,
        message)(executor, sender)</code>
</li>
<li><code>actor ? message</code>, it means &#8220;ask&#8221;, which resturns a <code>Future</code>
representing a possible reply. When you implement ask
function, you have to catch the exception and send a Failure
to the sender
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">try</span> {&#57344;&#57345;&#57345;
  <span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">result</span> = operation()&#57344;&#57345;&#57345;
  sender() <span style="color: #268bd2;">!</span> result&#57344;&#57345;&#57345;
} <span style="color: #859900;">catch</span> {&#57344;&#57345;&#57345;
  <span style="color: #859900;">case</span> e: Exception =&gt;&#57344;&#57345;&#57345;
    sender() <span style="color: #268bd2;">!</span> <span style="color: #268bd2;">akka</span>.<span style="color: #268bd2;">actor</span>.<span style="color: #268bd2;">Status</span>.Failure(e)&#57344;&#57345;&#57345;
    <span style="color: #859900;">throw</span> e&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
</pre>
</div>
<p>
You can set a timeout period for the <code>Future</code> by implicit
value <code>implicit val timeout = Timeout(5 seconds)</code> or using
curry function <code>myActor.ask(msg)(5 seconds)</code>.
</p>
</li>
</ol>
</li>
<li>Receiving messages
<ol class="org-ol">
<li><code>receive</code> defined method in actor will be called when message
comes. <b>Attention:</b>, the <code>sender()</code> method returns the current
sender when the method is called, <b>DO NOT</b> use this function
in callbacks since the sender method may returns wrong sender
(deadletter in many cases) when the callback is actually
invoked.
</li>
<li><code>inbox.receive</code>
</li>
<li>Set timeout period for receiving method,
<code>context.setReceiveTimeout(30 milliseconds)</code>. Then you can
catch this event by receiving message <code>case ReceiveTimeout</code>.
</li>
</ol>
</li>
<li>Forward message
<code>target forward message</code>, it will keep the sender unchanged. A
send msg to B, B forward msg to C, the sender for C is still A
instead of B
</li>
<li>Stop actor
<code>akka.actor.PoisonPill</code> message will stop the
actor. <code>gracefulStop</code> is useful to wait for termination or
compose ordered termination of several actors. It is a pattern,
not precoded, it sends a user defined message to the actor and
returns a <code>Future</code>, you can <code>Await</code> this future for a duration.

<p>
<code>actor ! Kill</code> will also stop this actor, but it causes the actor
to throw a <code>ActorKilledException</code>. This actor will suspend and
like the supervisor to decide how to handle the failure.
</p>
</li>
<li>Become/Unbecome
<code>context.become</code> method in Actor can setting the receive
function, hence the behavior of Actor is changed. <code>unbecome</code> lets
the actor returns to previews behavior.

<p>
You can use <code>stash</code> and <code>unstash</code> to save mails into a queue in
one behavior and get them back in another behavior. Of course,
you have to mix the trait <code>Stash</code> to be able to use it.
</p>
</li>
<li>Extend actor and intialization patterns
Use <code>PartialFunction#orElse</code> to chain the <code>receive</code> function of
the extended actor.

<p>
Three init patterns
</p>
<ol class="org-ol">
<li>constructor
</li>
<li>preStart
</li>
<li>Message
</li>
</ol>
</li>
</ul>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Falt toleration</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Example code from document.
</p>
<ol class="org-ol">
<li><code>Counter</code>, increment and save count to storage, return current
count number
</li>
<li><code>Storage</code>, simulate database, store (String, Long) pairs.
</li>
<li><code>CounterService</code>, override supervisorStrategy by
<code>OneForOneStrategy</code>
<div class="org-src-container">

<pre class="src src-java">override <span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">supervisorStrategy</span> = OneForOneStrategy(maxNrOfRetries = 3,&#57344;&#57345;
  withinTimeRange = 5.seconds) {&#57344;&#57345;&#57345;
  <span style="color: #859900;">case</span> _: <span style="color: #268bd2;">Storage</span>.StorageException =&gt; Restart&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
</pre>
</div>

<p>
init with actor refererences to the wrapper (watcher) of
storage, tell counter (when initialized?) to use the storage.
</p>

<p>
forward message (increment, getCurrentCount) to counter if it
exists; save <code>sender-&gt;msg</code> pair to log if counter is not
available.
</p>

<p>
if storage is terminated, tell counter that storage is not
available, schedule task to initStorage again (reconnect).
</p>
</li>
<li><code>Worker</code>, stop when receiving message from CounterService. init
<code>CounterService</code> actor.
</li>
<li><code>Listener</code>, shutdown the system while timeout. Listen
<code>Progress</code>, which is a case class of <code>Worker</code>.
</li>
<li>App object init worker and listener. Tell worker to assign the
listener, which will schedule task to use the <code>CounterService</code>
to increment count and pipe the message to listener.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Persistent Actor</h3>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Cluster</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Simple Cluster</h3>
<div class="outline-text-3" id="text-2-1">
</div><div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> Configuration</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
To run cluster, you have to first creat a configuration file that
specify the URI, actors, etc.
</p>
<pre class="example">
akka {
  actor {
    provider = "akka.cluster.ClusterActorRefProvider"
  }
  remote {
    log-remote-lifecycle-events = off
    netty.tcp {
      hostname = "127.0.0.1"
      port = 0
    }
  }

  cluster {
    seed-nodes = [
      "akka.tcp://ClusterSystem@127.0.0.1:2551",
      "akka.tcp://ClusterSystem@127.0.0.1:2552"]

    auto-down-unreachable-after = 10s
  }
}
</pre>
</div>
</div>

<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> Code</h4>
<div class="outline-text-4" id="text-2-1-2">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">package</span> sample.cluster.<span style="color: #268bd2;">simple</span>&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
<span style="color: #859900;">import</span> <span style="color: #268bd2;">com</span>.<span style="color: #268bd2;">typesafe</span>.<span style="color: #268bd2;">config</span>.<span style="color: #268bd2;">ConfigFactory</span>&#57344;&#57345;&#57345;
<span style="color: #859900;">import</span> <span style="color: #268bd2;">akka</span>.<span style="color: #268bd2;">actor</span>.<span style="color: #268bd2;">ActorSystem</span>&#57344;&#57345;&#57345;
<span style="color: #859900;">import</span> <span style="color: #268bd2;">akka</span>.<span style="color: #268bd2;">actor</span>.<span style="color: #268bd2;">Props</span>&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
<span style="color: #268bd2;">object</span> <span style="color: #6c71c4;">SimpleClusterApp</span> {&#57344;&#57345;&#57345;
  <span style="color: #268bd2;">def</span> <span style="color: #6c71c4;">main</span>(args: Array[String]): Unit = {&#57344;&#57345;&#57345;
    <span style="color: #859900;">if</span> (args.isEmpty)&#57344;&#57345;&#57345;
      startup(Seq(<span style="color: #2aa198;">"2551"</span>, <span style="color: #2aa198;">"2552"</span>, <span style="color: #2aa198;">"0"</span>))&#57344;&#57345;&#57345;
    <span style="color: #859900;">else</span>&#57344;&#57345;&#57345;
      startup(args)&#57344;&#57345;&#57345;
  }&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  <span style="color: #268bd2;">def</span> <span style="color: #6c71c4;">startup</span>(ports: Seq[String]): Unit = {&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">ports</span> <span style="color: #6c71c4;">foreach</span> { port =&gt;&#57344;&#57345;&#57345;
      <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">Override the configuration of the port</span>&#57344;&#57345;&#57345;
      val config = ConfigFactory.parseString(<span style="color: #2aa198;">"akka.remote.netty.tcp.port="</span> + port).&#57344;&#57345;
        withFallback(ConfigFactory.load())&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
      <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">Create an Akka system</span>&#57344;&#57345;&#57345;
      val system = ActorSystem(<span style="color: #2aa198;">"ClusterSystem"</span>, config)&#57344;&#57345;&#57345;
      <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">One system on one port?</span>&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
      <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">Create an actor that handles cluster domain events</span>&#57344;&#57345;&#57345;
      system.actorOf(<span style="color: #268bd2;">Props</span>[SimpleClusterListener], name = <span style="color: #2aa198;">"clusterListener"</span>)&#57344;&#57345;
    }&#57344;&#57345;&#57345;
  }&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
<span style="color: #859900;">class</span> <span style="color: #268bd2;">SimpleClusterListener</span> <span style="color: #859900;">extends</span> <span style="color: #268bd2;">Actor</span> with ActorLogging {&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  <span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">cluster</span> = Cluster(context.system)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">subscribe to cluster changes, re-subscribe when restart</span>&#57344;&#57345;&#57345;
  override def preStart(): Unit = {&#57344;&#57345;&#57345;
    <span style="color: #93a1a1; font-style: italic;">//</span><span style="color: #93a1a1; font-style: italic;">#subscribe</span>&#57344;&#57345;&#57345;
    cluster.subscribe(self, initialStateMode = InitialStateAsEvents,&#57344;&#57345;&#57345;
      classOf[MemberEvent], classOf[UnreachableMember])&#57344;&#57345;&#57345;
    <span style="color: #93a1a1; font-style: italic;">//</span><span style="color: #93a1a1; font-style: italic;">#subscribe</span>&#57344;&#57345;&#57345;
  }&#57344;&#57345;&#57345;
  override <span style="color: #268bd2;">def</span> <span style="color: #b58900;">postStop</span>(): Unit = cluster.unsubscribe(self)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  def receive = {&#57344;&#57345;&#57345;
    <span style="color: #859900;">case</span> MemberUp(member) =&gt;&#57344;&#57345;&#57345;
      log.info(<span style="color: #2aa198;">"Member is Up: {}"</span>, member.address)&#57344;&#57345;&#57345;
    <span style="color: #859900;">case</span> UnreachableMember(member) =&gt;&#57344;&#57345;&#57345;
      log.info(<span style="color: #2aa198;">"Member detected as unreachable: {}"</span>, member)&#57344;&#57345;&#57345;
    <span style="color: #859900;">case</span> MemberRemoved(member, previousStatus) =&gt;&#57344;&#57345;&#57345;
      log.info(<span style="color: #2aa198;">"Member is Removed: {} after {}"</span>,&#57344;&#57345;&#57345;
        member.address, previousStatus)&#57344;&#57345;&#57345;
    <span style="color: #859900;">case</span> _: MemberEvent =&gt; <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">ignore</span>&#57344;&#57345;&#57345;
  }&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3"><span class="section-number-4">2.1.3</span> Running</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
Log when starting the second seed node:
[info] [INFO] [03/10/2015 23:57:27.799]
[ClusterSystem-akka.actor.default-dispatcher-14]
[Cluster(akka://ClusterSystem)] Cluster Node
[akka.tcp://ClusterSystem@127.0.0.1:2551] - Node
[akka.tcp://ClusterSystem@127.0.0.1:2552] is JOINING, roles []
</p>

<p>
This code defines a cluster (集群), each node runs as dependennt
processes (different JVMs) since they all run on my local
machine. A cluster is indentified by <code>akka://CllusterSystem</code>,
while each node is indentified by IP address and port number. The
IP address seems like to be defined by application.config.
</p>

<ul class="org-ul">
<li><b>seed nodes</b> are configured contact points for initial,
automatic, join of the cluster. Hence, the <code>seed-nodes</code> figure
out where to join the cluster to current node. The seed nodes can
also be configured by command line options when starting the JVM
using the following syntax:
<div class="org-src-container">

<pre class="src src-bash">-Dakka.cluster.seed-nodes.0=akka.tcp://ClusterSystem@host1:2552
-Dakka.cluster.seed-nodes.1=akka.tcp://ClusterSystem@host1:2552
</pre>
</div>
<p>
Starting seed notes can be async and not all the seed nodes are
necessary to run. But the first node must be started when
starting a cluster.
</p>

<p>
It is also possible to join the cluster manually via <a href="http://doc.akka.io/docs/akka/2.3.9/scala/cluster-usage.html#cluster-jmx-scala"><i>JMX</i></a> or
<a href="http://doc.akka.io/docs/akka/2.3.9/scala/cluster-usage.html#cluster-command-line-scala"><i>Command Line Management</i></a> or via programatic method with
<code>Cluster.get(system).join(address)</code> or
<code>Cluster(system).joinSeedNodes</code>.
</p>
</li>
<li><code>hostname</code> in <code>remote</code> in configuration specify the IP of
current node. <b>Question:</b> /what if I specify the IP to another
machine? The application should be deploy to another machine
before running? What protocole does it uses?/
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Dial-in example</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Frontend-backend pattern (not those in Group router):
</p>
<ol class="org-ol">
<li>Backed subscribes to the cluster service to register new
frontend
</li>
<li>Frontend watch the backend and define the <code>receive</code> method for
the case of <code>Terminated(a)</code>.
</li>
<li>Frontend redirect received jobs to backend.
</li>
<li>Roles of node is defined in the configuration property named
<code>akka.cluster.roles</code> or in start script as a system property
or environment variable.
</li>
</ol>

<p>
Number of members restriction:
<code>akka.cluster.min-nr-of-members = 3</code>, the leader will not
change the status of nodes to &#8216;Up&#8217; until this number of
members reached. Finer configuration:
</p>
<p>
#+beign_src yaml
akka.cluster.role {
  frontend.min-nr-of-members = 1
  backend.min-nr-of-members = 2
}
</p>
<p>
#+end_src
Define callback to be invoked when the current member status is
changed to &#8216;Up&#8217;
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">Cluster</span>(<span style="color: #268bd2;">system</span>) registerOnMemberUp {&#57344;&#57345;&#57345;
  system.actorOf(Props(classOf[FactorialFrontend], upToN, <span style="color: #268bd2;">true</span>),&#57344;&#57345;&#57345;
    name = <span style="color: #2aa198;">"factorialFrontend"</span>)&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Cluster Aware Routers</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Router is one that receive and send tasks to actors, while the
ref to actors are called routees.
</p>
</div>

<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1"><span class="section-number-4">2.3.1</span> <b>Group router</b></h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
在示例代码中,每一个node上面都有一个StatsService,和一个
StatsWorker. StatsService里面包含了指向StatsWorker的router并且负
责接受和转发任务. 每次Client将一个任务传给Cluster时,Cluster中某
个一node上的StatsService会接收并分发任务,因为分发任务是依靠
router来实现的,所以任务会被分发到不同node上的StatsWorker上去.这
个例子中,每个node上的Service和Worker都是显式创建的.
</p>

<p>
<b>Group example: Server side</b>
</p>
<div class="org-src-container">

<pre class="src src-yaml">akka.actor.deployment {&#57344;&#57345;&#57345;
  /statsService/workerRouter {&#57344;&#57345;&#57345;
      router = consistent-hashing-group&#57344;&#57345;&#57345;
      // specify the router, you have also other options like round-robin-pool&#57344;&#57345;
      nr-of-instances = 100&#57344;&#57345;&#57345;
      routees.paths = [<span style="color: #2aa198;">"/user/statsWorker"</span>]&#57344;&#57345;&#57345;
      cluster {&#57344;&#57345;&#57345;
        enabled = on&#57344;&#57345;&#57345;
        allow-local-routees = on&#57344;&#57345;&#57345;
        use-role = compute&#57344;&#57345;&#57345;
      }&#57344;&#57345;&#57345;
    }&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
</pre>
</div>
<p>
With this configuration, relative actor paths defined in
<code>routees.paths</code> are used for selecting actors to send the message
by the router.
在创建System的时候将这个配置文件包含到配置中去, 然后在这个system
下面任意地方用 <code>actorOf(FromConfig.props(Props[YourClass]))</code> 来
得到router actor. 发送任务时将任务发给router actor,它会自动转发
给cluster中的注册在 &#8220;user&#8221; 下面的注册名为 &#8220;statsWorker&#8221; 的actor
(不一定是StatsWorker,你可以随意将不同类型的Actor注册在这个名字下
面). 更多的配置,查看<a href="http://doc.akka.io/docs/akka/snapshot/scala/routing.html">routing</a>.
</p>

<p>
下面的代码是用编程的方式实现配置文件里的配置.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">workerRouter</span> = context.actorOf(&#57344;&#57345;&#57345;
    ClusterRouterGroup(ConsistentHashingGroup(Nil), ClusterRouterGroupSettings(&#57344;&#57345;
      totalInstances = 100, routeesPaths = List(<span style="color: #2aa198;">"/user/statsWorker"</span>),&#57344;&#57345;&#57345;
      allowLocalRoutees = <span style="color: #268bd2;">true</span>, useRole = Some(<span style="color: #2aa198;">"compute"</span>))).props(),&#57344;&#57345;&#57345;
    name = <span style="color: #2aa198;">"workerRouter2"</span>)&#57344;&#57345;&#57345;
</pre>
</div>

<p>
<b>Group example: Client side</b>
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">object</span> <span style="color: #6c71c4;">StatsSampleClient</span> {&#57344;&#57345;&#57345;
  <span style="color: #268bd2;">def</span> <span style="color: #6c71c4;">main</span>(args: Array[String]): Unit = {&#57344;&#57345;&#57345;
    <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">note that client is not a compute node, role not defined</span>&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">system</span> = ActorSystem(<span style="color: #2aa198;">"ClusterSystem"</span>)&#57344;&#57345;&#57345;
    system.actorOf(Props(classOf[StatsSampleClient], <span style="color: #2aa198;">"/user/statsService"</span>), <span style="color: #2aa198;">"client"</span>)&#57344;&#57345;
  }&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
<span style="color: #859900;">class</span> <span style="color: #268bd2;">StatsSampleClient</span>(servicePath: String) <span style="color: #859900;">extends</span> <span style="color: #268bd2;">Actor</span> {&#57344;&#57345;&#57345;
  <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">servicePath is "/user/statsService", which is the second argument of the Props.</span>&#57344;&#57345;
  <span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">cluster</span> = Cluster(context.system)&#57344;&#57345;&#57345;
  val servicePathElements = servicePath match {&#57344;&#57345;&#57345;
    <span style="color: #859900;">case</span> RelativeActorPath(elements) =&gt; {&#57344;&#57345;&#57345;
<span style="color: #93a1a1; font-style: italic;">//      </span><span style="color: #93a1a1; font-style: italic;">println("servicePath is: "+servicePath) ;</span>&#57344;&#57345;&#57345;
      elements}&#57344;&#57345;&#57345;
    <span style="color: #859900;">case</span> _ =&gt; <span style="color: #859900;">throw</span> <span style="color: #859900;">new</span> <span style="color: #268bd2;">IllegalArgumentException</span>(&#57344;&#57345;&#57345;
      <span style="color: #2aa198;">"servicePath [%s] is not a valid relative actor path"</span> format servicePath)&#57344;&#57345;
  }&#57344;&#57345;&#57345;
  <span style="color: #859900;">import</span> context.<span style="color: #268bd2;">dispatcher</span>&#57344;&#57345;&#57345;
  <span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">tickTask</span> = context.system.scheduler.schedule(2.seconds, 10.seconds, self, <span style="color: #2aa198;">"tick"</span>)&#57344;&#57345;
&#57344;&#57345;&#57345;
  var nodes = Set.empty[Address]&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  override def preStart(): Unit = {&#57344;&#57345;&#57345;
    cluster.subscribe(self, classOf[MemberEvent], classOf[ReachabilityEvent])&#57344;&#57345;
  }&#57344;&#57345;&#57345;
  override <span style="color: #268bd2;">def</span> <span style="color: #b58900;">postStop</span>(): Unit = {&#57344;&#57345;&#57345;
    cluster.unsubscribe(self)&#57344;&#57345;&#57345;
    tickTask.cancel()&#57344;&#57345;&#57345;
  }&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  <span style="color: #268bd2;">def</span> <span style="color: #6c71c4;">receive</span> = {&#57344;&#57345;&#57345;
    <span style="color: #859900;">case</span> <span style="color: #2aa198;">"tick"</span> <span style="color: #859900;">if</span> nodes.nonEmpty =&gt;&#57344;&#57345;&#57345;
      <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">just pick any one</span>&#57344;&#57345;&#57345;
      val address = nodes.toIndexedSeq(ThreadLocalRandom.current.nextInt(nodes.size))&#57344;&#57345;
      val service = context.actorSelection(<span style="color: #268bd2;">RootActorPath</span>(<span style="color: #268bd2;">address</span>) / servicePathElements)&#57344;&#57345;
      service <span style="color: #268bd2;">!</span> StatsJob(<span style="color: #2aa198;">"this is the text that will be analyzed"</span>)&#57344;&#57345;&#57345;
    <span style="color: #859900;">case</span> result: StatsResult =&gt;&#57344;&#57345;&#57345;
      println(result)&#57344;&#57345;&#57345;
    <span style="color: #859900;">case</span> failed: JobFailed =&gt;&#57344;&#57345;&#57345;
      println(failed)&#57344;&#57345;&#57345;
    <span style="color: #859900;">case</span> state: CurrentClusterState =&gt;&#57344;&#57345;&#57345;
      nodes = state.members.collect {&#57344;&#57345;&#57345;
        <span style="color: #859900;">case</span> m <span style="color: #859900;">if</span> m.hasRole(<span style="color: #2aa198;">"compute"</span>) &amp;&amp; m.status == <span style="color: #268bd2;">MemberStatus</span>.Up =&gt; m.address&#57344;&#57345;
      }&#57344;&#57345;&#57345;
    <span style="color: #859900;">case</span> MemberUp(m) <span style="color: #859900;">if</span> m.hasRole(<span style="color: #2aa198;">"compute"</span>)        =&gt; nodes += m.address&#57344;&#57345;
    <span style="color: #859900;">case</span> other: MemberEvent                         =&gt; nodes -= other.member.address&#57344;&#57345;
    <span style="color: #859900;">case</span> UnreachableMember(m)                       =&gt; nodes -= m.address&#57344;&#57345;
    <span style="color: #859900;">case</span> ReachableMember(m) <span style="color: #859900;">if</span> m.hasRole(<span style="color: #2aa198;">"compute"</span>) =&gt; nodes += m.address&#57344;&#57345;
  }&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
</pre>
</div>
<p>
而在客户端代码中,首先向cluster订阅成员事件来获取所有的成员. 然后
根据成员的role来筛选出相应的node. 真正开始发送任务的时候,随机排
列这些node,然后使用
<code>context.actorSelection(RootActorPath(address) /
      servicePathElements)</code> 这句话返回一个 <code>ActorSelection</code> 的对象,对它
发送信息能自动地发送到某个注册在cluster上的某个node上的某个actor
上面去.准确地说,后半段确定Actor的URN,前半段应该是URL.
</p>
</div>
</div>

<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2"><span class="section-number-4">2.3.2</span> <b>Pool router</b></h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
利用ClusterSingletonManager作为StatsService的外包,虽然每个node上
都运行了创建代码,但实际上只有一个StatsService被创建,从而实现单例.
在node被创建之后,node沟通其它node并加入cluster,随后连接上singleton
下的statsService,如果是第一个node则会创建router,然后创建3个
worker. 之后的node直接在连上statsService之后创建3个worker. worer是
由workerRouter创建的,3个worker的设定在配置文件里
<code>max-nr-of-instances-per-node = 3</code>. 这个设定只对pool有效,group里
面就算设定了也不会创建worker.
</p>

<p>
<i>singlton意味着Actor在整个集群上只有一个,目前看来是先创建的node
上面载有这个单例,如果这个node挂了怎么办?</i>
</p>

<p>
singletonManager 被映射到 /user/singleton 上作为 StatsService 的
容器, StatsService 自然就映射到其下
<code>/user/singleton/statsService</code>.
</p>
</div>
</div>
</div>


<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Adaptive Load Balancing</h3>
<div class="outline-text-3" id="text-2-4">
<p>
AdaptiveLoadBalanceing <b>Pool</b> 和 AdaptiveLoadBalancing <b>Group</b> 两种
实现方式.中心是cluster metrics和配置adaptive的router.
</p>
<ol class="org-ol">
<li>注意,不要在 <code>preStart</code> 里面发送信息,这个时候路由还没有设置好,发
送的message全部/部分都会变成 <i>dead letter</i>.
</li>
<li>另外一个坑是:router会按照算法把负载分布到cluster的每个node上去.在
例子中,用role来区分前后端的node,所以router只会向后端node发送信
息.但是后端node不代表有后端actor,这一点router是无法探知的.所以
如果你把只运行有前端actor的node也标记为后端,router仍然会向其发
送信息,最后会导致信息送丢了. <b>node的身份取只决于system config里
面的role,不取决于里面到底运行了什么actor.</b>
</li>
<li>追加一个坑:不要在callback里面调用任何状态相关的函数,除非你确定
你需要这个副作用.在callback里面调用 <code>sender()</code> 经常会返回
<code>deadLetter</code>, 因为 <code>sender()</code> 真正被调用的时候不是接收到信息的
时候.
</li>
</ol>
</div>
</div>
</div>

]]></content>
</entry>

<entry>
<title type="html"><![CDATA[Principles of Reactive Programming on Coursera]]></title>
<link href="http://xiaoliuai.github.io/blog/2015-02-28-principles-of-reactive-programming-on-coursera.html"/>
<updated>2015-02-28T00:00:00+01:00</updated>
<id>http://xiaoliuai.github.io/blog/principles-of-reactive-programming-on-coursera</id>
<content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Monad</a></li>
<li><a href="#sec-2">2. ScalaCheck &amp; ScalaTest &amp; JUnit</a>
<ul>
<li><a href="#sec-2-1">2.1. Tutorial of ScalaCheck</a></li>
<li><a href="#sec-2-2">2.2. ScalaTest</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1. With JUnit</a></li>
<li><a href="#sec-2-2-2">2.2.2. With ScalaCheck</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">3. Async</a>
<ul>
<li><a href="#sec-3-1">3.1. Exception =&gt; Future</a></li>
<li><a href="#sec-3-2">3.2. Iterable =&gt; Observable</a>
<ul>
<li><a href="#sec-3-2-1">3.2.1. Subject</a></li>
<li><a href="#sec-3-2-2">3.2.2. Notification</a></li>
<li><a href="#sec-3-2-3">3.2.3. Subscription</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><a href="xiaoliuai.github.io/tags/scala/atom.xml"><span class="section-number-2">1</span> Monad</a></h2>
<div class="outline-text-2" id="text-1">
<p>
Honestly, I don&#8217;t understand it. But I collect my thoughts about it
here. First, the monda is used to chain operations and if the first
(preceding) operation fails, the whole chain stops. An example that
I understand is the usage of for-expression with pattern match. If
the pattern matches, go next operation, else skip this element.
</p>

<p>
Another point of view is about the unit operation. A monad flatMap
with its unit operation will return the monad itself.
</p>

<p>
<b>My conclusion</b>:
</p>

<p>
A monad is a container that supports operation chain and follows
the monad laws. The basic operations of this container are
<code>flatMap</code> and <code>unit</code>, where <code>flatMap</code> actually accepts a function
that maps each element to a container, then binds these containers
together; <code>unit</code> returns a container given an element. Monad laws
guarantee the reliability of operation chain on these contains.
</p>

<p>
Monad seems like a design pattern that enables the operation chain
along with pattern match in functional programming. Because
<code>flatMap</code> chain with different functions is equivalent to nested
<code>flatMap</code>, the for-expression is a syntax sugar based on <code>flatMap</code>
chain. The advantage of this design pattern is avoding side effect.
</p>

<p>
Generator is created by <code>yield</code> as well as
<b>for-expression</b>. Pay attention, there is no generator
class/type/trait. The genrator created through for-expression has
the same type of the sequence/iterator/stream used in
for-expression. That proves the for-expression is a syntax sugar of
monad types. So, guess what will happen when we create a
for-expression using both <b>list</b> and <b>stream</b>?
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">fibo</span>:Stream[Int] = 1 #:: 1 #:: fibo.zip(fibo.tail).map(x=&gt;x._1+x._2)&#57344;&#57345;
val l = List(1,2,3,4,5)&#57344;&#57345;&#57345;
val lsg = <span style="color: #859900;">for</span>{x &lt;- l; fib &lt;- fibo} yield (x,fib)<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">infinite loop, crash the software/your machine</span>&#57344;&#57345;
val slg = <span style="color: #859900;">for</span>{fib &lt;- fibo; x &lt;- l} yield (x,fib)<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">return a stream</span>&#57344;&#57345;&#57345;
</pre>
</div>
<p>
Following the definition of Monad, the first mixture <code>lsg</code> actually
makes <code>l flatMap (x =&gt; fibo)</code>, which returns a List that tries to
expand infinite stream <code>fibo</code>, hence block your machine. The second
mixture <code>slg</code> returns a Stream that expand the list <code>l</code>, hence,
works well. Besides, I have to clarify one thing: different monads
demonstrated above all accept <code>GenTraversableOnce</code> as parameter and
return monad of their own type. That is why they can be mixed
together and the first expression decides the type of the final
output of for-expression.
</p>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> ScalaCheck &amp; ScalaTest &amp; JUnit</h2>
<div class="outline-text-2" id="text-2">
<p>
In the example provided by the oneline course, they used <b>JUnit</b>,
<b>ScalaTest</b> and <b>ScalaCheck</b> together. In their example, the class
of <code>Properties</code> is in <code>src/main/scala</code> and is called by another
class defined under <code>src/test/scala</code>. In the class under test
folder, many instances of the <code>Properties</code> class are created to
check different children classes of the target class.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">abstract</span> <span style="color: #859900;">class</span> <span style="color: #268bd2;">QuickCheckHeap</span> <span style="color: #859900;">extends</span> <span style="color: #268bd2;">Properties</span>(<span style="color: #2aa198;">"Heap"</span>) with IntHeap {&#57344;&#57345;
&#57344;&#57345;&#57345;
  property(<span style="color: #2aa198;">"min1"</span>) = forAll { <span style="color: #268bd2;">a</span>: Int =&gt;&#57344;&#57345;&#57345;
    val h = insert(a, empty)&#57344;&#57345;&#57345;
    findMin(h) == a&#57344;&#57345;&#57345;
  }&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  lazy <span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">genHeap</span>: Gen[H] = <span style="color: #859900;">for</span> {&#57344;&#57345;&#57345;
    a &lt;- arbitrary[Int]&#57344;&#57345;&#57345;
    h &lt;- oneOf(value(empty), genHeap)&#57344;&#57345;&#57345;
  } <span style="color: #268bd2;">yield</span> <span style="color: #b58900;">insert</span>(<span style="color: #268bd2;">a</span>, <span style="color: #268bd2;">h</span>)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  implicit lazy val arbHeap: Arbitrary[H] = Arbitrary(genHeap)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
</pre>
</div>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">@RunWith</span>(<span style="color: #268bd2;">classOf</span>[JUnitRunner])&#57344;&#57345;&#57345;
<span style="color: #859900;">class</span> <span style="color: #268bd2;">QuickCheckSuite</span> <span style="color: #859900;">extends</span> <span style="color: #268bd2;">FunSuite</span> with Checkers {&#57344;&#57345;&#57345;
  <span style="color: #268bd2;">def</span> <span style="color: #b58900;">checkBogus</span>(p: Prop) {&#57344;&#57345;&#57345;
    <span style="color: #268bd2;">var</span> <span style="color: #6c71c4;">ok</span> = <span style="color: #268bd2;">false</span>&#57344;&#57345;&#57345;
    <span style="color: #859900;">try</span> {&#57344;&#57345;&#57345;
      check(p)&#57344;&#57345;&#57345;
    } <span style="color: #859900;">catch</span> {&#57344;&#57345;&#57345;
      <span style="color: #859900;">case</span> e: TestFailedException =&gt;&#57344;&#57345;&#57345;
        ok = <span style="color: #268bd2;">true</span>&#57344;&#57345;&#57345;
    }&#57344;&#57345;&#57345;
    assert(ok, <span style="color: #2aa198;">"A bogus heap should NOT satisfy all properties. Try to find the bug!"</span>)&#57344;&#57345;
  }&#57344;&#57345;&#57345;
  <span style="color: #b58900;">test</span>(<span style="color: #2aa198;">"Binomial heap satisfies properties."</span>) {&#57344;&#57345;&#57345;
    check(<span style="color: #859900;">new</span> <span style="color: #268bd2;">QuickCheckHeap</span> with BinomialHeap)&#57344;&#57345;&#57345;
  }&#57344;&#57345;&#57345;
  <span style="color: #b58900;">test</span>(<span style="color: #2aa198;">"Bogus (1) binomial heap does not satisfy properties."</span>) {&#57344;&#57345;&#57345;
    checkBogus(<span style="color: #859900;">new</span> <span style="color: #268bd2;">QuickCheckHeap</span> with Bogus1BinomialHeap)&#57344;&#57345;&#57345;
  }&#57344;&#57345;&#57345;
  <span style="color: #b58900;">test</span>(<span style="color: #2aa198;">"Bogus (2) binomial heap does not satisfy properties."</span>) {&#57344;&#57345;&#57345;
    checkBogus(<span style="color: #859900;">new</span> <span style="color: #268bd2;">QuickCheckHeap</span> with Bogus2BinomialHeap)&#57344;&#57345;&#57345;
  }&#57344;&#57345;&#57345;
  <span style="color: #b58900;">test</span>(<span style="color: #2aa198;">"Bogus (3) binomial heap does not satisfy properties."</span>) {&#57344;&#57345;&#57345;
    checkBogus(<span style="color: #859900;">new</span> <span style="color: #268bd2;">QuickCheckHeap</span> with Bogus3BinomialHeap)&#57344;&#57345;&#57345;
  }&#57344;&#57345;&#57345;
  <span style="color: #b58900;">test</span>(<span style="color: #2aa198;">"Bogus (4) binomial heap does not satisfy properties."</span>) {&#57344;&#57345;&#57345;
    checkBogus(<span style="color: #859900;">new</span> <span style="color: #268bd2;">QuickCheckHeap</span> with Bogus4BinomialHeap)&#57344;&#57345;&#57345;
  }&#57344;&#57345;&#57345;
  <span style="color: #b58900;">test</span>(<span style="color: #2aa198;">"Bogus (5) binomial heap does not satisfy properties."</span>) {&#57344;&#57345;&#57345;
    checkBogus(<span style="color: #859900;">new</span> <span style="color: #268bd2;">QuickCheckHeap</span> with Bogus5BinomialHeap)&#57344;&#57345;&#57345;
  }&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
</pre>
</div>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Tutorial of ScalaCheck</h3>
<div class="outline-text-3" id="text-2-1">
<p>
It is a tool for <b>property-based</b> testing for scala. It has <b>NO</b>
external dependencies and integrated in the test frameworks
<b>ScalaTest</b>. It can also be used standalone, with its built-in test
runner.
First, create a class that extends class
<code>org.scalacheck.Properties</code> with the name of data object that you
want to test. It is used for the library to generate test data to
test your algorithm.
</p>

<p>
Second, create test case by
</p>
<div class="org-src-container">

<pre class="src src-java">property(<span style="color: #2aa198;">"NAME_OF_FUNCTION"</span>) = forAll{&#57344;&#57345;&#57345;
    CONTAINER_OF_DATA =&gt; TEST_CASE_WITH_TARGET_FUNCTION&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
</pre>
</div>
<p>
<code>forAll</code> is the function <code>org.scalacheck.Prop.forAll</code>.
</p>

<p>
Third, to run the tests, you can put the properties in
<code>src/test/scala</code> then use test task to check them.
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> ScalaTest</h3>
<div class="outline-text-3" id="text-2-2">
<p>
This is a test framework that integrates all together. ScalaTest
provides many test styles: <code>FunSuit</code>, <code>FlatSpec</code>, <code>FuncSpec</code>,
<code>WordSpec</code>, <code>FreeSpec</code>, <code>Spec</code>, <code>PropSpec</code>, <code>FeatureSpec</code>. They
are mainly different on syntax styles. It is recommanded that the
user creates a base class that extends all the required features
(as a subset of all the provided features) and extends this base
class through everywhere of the project to make the style
consistent.
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> With JUnit</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
This class uses the junit framework for unittest. JUnit will
invoke the class with <code>@RunWith</code> annotation (extend by type
hierarchies) to run the tests. The annotation parameter in the
example is a class of the type <code>JUnitRunner</code>. In fact, any class
extends <code>Runner</code> is acceptabel. Notice that function <code>classOf</code>
acts the same as <code>obj.getClass()</code>.
</p>

<p>
<b>Maven</b> Running tests with command <code>mvn test</code>. In fact, you
<b>cannot</b> run the tests with the example above. <b>Solution</b> is to
change the name <code>QuickCheckSuite</code> to <code>QuickCheckSuiteTest</code> or
<code>TestQuickCheckSuite</code> or <code>QuickCheckSuiteTestCase</code> to run the
tests. Even I did not explicitly specify plugin <code>surefire</code>, maven
uses this plugin to run test with my configuration. By default,
maven following name convertions when looking for tests to
run. So I have to change the name or modify the <code>surefire</code>
configuration to apply new name convertion rules.
</p>

<p>
The annotation uses class of <code>JUnitRunner</code> as parameter. This
class is provided by scala-test framework that connect
scala-test and junit.
</p>
<ul class="org-ul">
<li>As mentioned on <a href="http://www.scalatest.org/user_guide/using_the_scalatest_maven_plugin">ScalaTest Maven Plugin</a>, you can run tests
without this annotation by using this plugin. <b>TODO</b>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> With ScalaCheck</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
To work with ScalaCheck, you have to mix the trait
<code>org.scalatest.prop.Checkers</code> to your test class. <code>Checkers</code>
class contains <code>check</code> method to perform ScalaCheck property
checks, which are provided in the class <code>QuickCheckHeap</code> in the
example above. In fact, you can also use the <code>check</code> method in
JUnit directly. This method will generate a large number of
possible inputs to look for an input that the property does not
hold.
</p>
</div>
</div>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Async</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Exception =&gt; Future</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Exception is handled by <b>Try[T]</b>, which is used as return type like
Option. But Try[T] maches Success with result or Failure with
throwable. As Try[T] is also a monad, operations of element T are
usually propagated to monad methods of Try[T] to get a new Try[U],
<b>map Try[T] by f should return a new Try[f(T)]</b>.
</p>

<p>
<b>Future[T]</b> is a container of Try[T]. User provide
operations/callbacks that deal with Try[T] and future will call
them at certain time. <b>Future</b> and <b>Try</b> form a nested monad,
monad operations are propagated and you cannot see direct
operation on T in the source code of scala library. But take it
easy, usually, you won&#8217;t have to do it yourself.
</p>

<p>
To <b>get/compose</b> a future (that can be our job), therer are four
methods:
</p>
<ol class="org-ol">
<li>Use the member function of a <code>Future</code> such as <code>flatMap</code>
<ol class="org-ol">
<li><code>flatMap</code>, binary bind operation of futures. Register promise
to <i>this</i> when failed of exception of call funtion; register
promise to <i>that</i> when successed.
</li>
<li><code>onComplete</code>, parameter is a function <code>Try[T] =&gt; U</code>. This is
a funtamental funciton of <code>map</code>, <code>foreach</code>, <code>failed</code>, etc. It
propagate the Try mechanism.
</li>
<li><code>collect</code>
</li>
<li><code>recover</code>
</li>
<li><code>fallbackTo</code>
</li>
<li><code>zip</code>
</li>
<li><code>andThen</code>
</li>
</ol>
</li>
<li>Create a promise and register the complete method to current
futures, then return a new Future of this promise.

<p>
<code>Promise</code> acts like a mailbox, to compose a new future, the old
future has to put the result, which is a Try[T], into the
promise by <code>complete</code> method. Then the new future will call its
callback when the <code>complete</code> of promise is called.
</p>

<p>
In my opinion, promise can be merged with feature as one
unit. Because it is more straight to think in the way that:
<i>feature calls the callbacks when it is completed</i>. In fact,
the <code>DefaultPromise</code> is actually extends the <code>Future</code> trait. Of
course, the designers of scala have their proper reason.
</p>

<p>
Currently, I think promise is used in race (concurrent
processing of futures results) or to provide a new future for
initailization of fold operations.
</p>
</li>
<li>Use <code>for-expression</code>, which is a syntax sugar of <code>flatMap</code>
</li>
<li>Use <code>async...await</code> grammar.
<ol class="org-ol">
<li><b>The scala implementation of await
is translated to onComplete by the macro</b>.
</li>
<li><b>await method throw
directly the excepetion when future failed</b>.
</li>
</ol>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Iterable =&gt; Observable</h3>
<div class="outline-text-3" id="text-3-2">
<p>
<code>Try</code> and <code>Future</code> are dual, so as <code>Iterable</code> and
<code>Observable</code>. For iterable, you can get an iterator and using
<code>hasNext</code> and <code>next</code> to get elements. For <code>Obserable</code>, you use
<code>Subscribe</code> and <code>onNext</code>, <code>onComplete</code> to get elements.
</p>

<p>
<code>flatten</code> after <code>map</code> returns an observable that merges several
streams randomly. <code>concat</code> after <code>map</code> returns an observable, in
which, elements of each stream are grouped together sequentially
as well as the order of the streams.
</p>

<p>
<b>Don&#8217;t understand well the way of creating observable with a
function from Observer to Subscription -_-!</b>
</p>
</div>

<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> Subject</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
It works like promise, which is used as bridge or chain between
Obsever and Observable. Four types of subjects are provided:
</p>
<ol class="org-ol">
<li>PublishSubject: send current value.
</li>
<li>BehaviorSubject: cache the latest output.
</li>
<li>AsyncSubject: cache the final output. You only get the final
output.
</li>
<li>ReplaySubject: cache the whole history.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> Notification</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
Like Try
</p>
</div>
</div>

<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3"><span class="section-number-4">3.2.3</span> Subscription</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
a handle that enables process to stop receiving messages from
Observable.
</p>
</div>
</div>
</div>
</div>

]]></content>
</entry>

<entry>
<title type="html"><![CDATA[Functional Programming on Coursera]]></title>
<link href="http://xiaoliuai.github.io/blog/2015-02-28-functional-programming-on-coursera.html"/>
<updated>2015-02-28T00:00:00+01:00</updated>
<id>http://xiaoliuai.github.io/blog/functional-programming-on-coursera</id>
<content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Lambda function</a></li>
<li><a href="#sec-2">2. Type hierachy</a></li>
<li><a href="#sec-3">3. Pattern match</a></li>
<li><a href="#sec-4">4. Collections</a></li>
<li><a href="#sec-5">5. Stream, Iterator, Generator and <code>lazy</code></a>
<ul>
<li><a href="#sec-5-1">5.1. Stream</a></li>
<li><a href="#sec-5-2">5.2. Iterator</a></li>
<li><a href="#sec-5-3">5.3. <code>lazy val</code></a></li>
</ul>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><a href="xiaoliuai.github.io/tags/scala/atom.xml"><span class="section-number-2">1</span> Lambda function</a></h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>function is value,
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">f</span> = (x:Int) =&gt; x*x&#57344;&#57345;&#57345;
</pre>
</div>
<p>
One difference between <code>def f = ...</code> and <code>val f = ...</code> is: <code>def</code>
is evaluated on call and returns a new function instance every
time.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">val</span> <span style="color: #b58900;">test</span>: () =&gt; Int = {&#57344;&#57345;&#57345;
    println(<span style="color: #2aa198;">"val"</span>)&#57344;&#57345;&#57345;
    val r = <span style="color: #268bd2;">util</span>.Random.nextInt&#57344;&#57345;&#57345;
    () =&gt; r&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">returns the same result every time you call test(),</span>&#57344;&#57345;&#57345;
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">"val" will be printed after definition</span>&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
<span style="color: #268bd2;">def</span> <span style="color: #b58900;">test</span>: () =&gt; Int = {&#57344;&#57345;&#57345;
    println(<span style="color: #2aa198;">"def"</span>)&#57344;&#57345;&#57345;
    val r = <span style="color: #268bd2;">util</span>.Random.nextInt&#57344;&#57345;&#57345;
    () =&gt; r&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">returns the difference results every time you call test(),</span>&#57344;&#57345;&#57345;
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">"def" will be printed every time you call it.</span>&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
<span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">tt</span> = test&#57344;&#57345;&#57345;
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">acts like the first example</span>&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
val test = () =&gt; <span style="color: #268bd2;">util</span>.Random.nextInt&#57344;&#57345;&#57345;
def test = () =&gt; <span style="color: #268bd2;">util</span>.Random.nextInt&#57344;&#57345;&#57345;
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">they are the same from behavior, you have to call the function by test()</span>&#57344;&#57345;
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">the def declaration actually defined a function that returns a function.</span>&#57344;&#57345;
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">if you type test without parenthesis, you will receive a function value.</span>&#57344;&#57345;
&#57344;&#57345;&#57345;
def test = <span style="color: #268bd2;">util</span>.Random.nextInt&#57344;&#57345;&#57345;
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">this line directly assign the test function to the nextInt function,</span>&#57344;&#57345;
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">you can call the function directly by name without the parenthesis</span>&#57344;&#57345;&#57345;
</pre>
</div>
<p>
method/expression starts by <code>def</code> will be evaluated when you call
<code>obj.f</code> while those starts by <code>val</code> will be evaluated
once. In addition, if you declare a <code>val</code> that assigns to <code>def</code>,
the <code>def</code> will be evaluated immediately, and the new <code>val</code> acts
like the first case in the examples above.
</p>
</li>
<li>Abbreviation:
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">l</span> = List(1,2,3)&#57344;&#57345;&#57345;
l.map((x) =&gt; x*x)&#57344;&#57345;&#57345;
l.map( x =&gt; x*x) <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">ignore the parenthese</span>&#57344;&#57345;&#57345;
l.map( _ % 2 == 0) <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">ignore the parameter, using the placeholder for expression</span>&#57344;&#57345;
l.map(f(_)) <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">using the placeholder for function</span>&#57344;&#57345;&#57345;
l.map(f) <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">ignore the placeholder for function</span>&#57344;&#57345;&#57345;
</pre>
</div>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Type hierachy</h2>
<div class="outline-text-2" id="text-2">
<p>
abstract class is like Java, trait is like interface in
Java. However, trait can have parameters and defined methods. In
addition, trait is not abstract class since it cannot has
constructors.
</p>
<ul class="org-ul">
<li>Logical problem: is List&lt;Parent&gt; the parent of List&lt;Childe&gt;?

<p>
It is not true for mutable collection.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">var</span> <span style="color: #6c71c4;">s</span> = <span style="color: #859900;">new</span> <span style="color: #268bd2;">Array</span>[Man](<span style="color: #859900;">new</span> <span style="color: #268bd2;">Man</span>())&#57344;&#57345;&#57345;
var t:Array[Human] = s&#57344;&#57345;&#57345;
t[0] = <span style="color: #859900;">new</span> <span style="color: #268bd2;">Woman</span>()&#57344;&#57345;&#57345;
var m:Man = s[0]<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">what is it? man or woman?</span>&#57344;&#57345;&#57345;
</pre>
</div>
<p>
But we can use imutable collection.
</p>
</li>

<li>Covariant, Contvariant, Invariant
<ul class="org-ul">
<li>Covariant: defined by Class&lt;+T&gt;, Class&lt;Parent&gt; is the parent of
Class&lt;Child&gt;
</li>

<li>Contvariant: defined by Class&lt;-T&gt;, Function&lt;Parent&gt; is the
child of Function&lt;Child&gt;
</li>
</ul>
<p>
The principle is: child type can do anything that can be done by
parent type.
</p>
</li>

<li>Check Rules and Boundary

<p>
To avoid conflict, the compile force the +T can only be used for
returned type, the -T can only be used for argument type. A
method to by pass this problem is using boundary.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">class</span> <span style="color: #268bd2;">List</span>&lt;+T&gt;{&#57344;&#57345;&#57345;
     <span style="color: #268bd2;">def</span> <span style="color: #6c71c4;">prepend</span>[U &gt;: T](<span style="color: #268bd2;">U</span> <span style="color: #6c71c4;">elem</span>)&#57344;&#57345;&#57345;
}&#57344;&#57345;&#57345;
</pre>
</div>
<p>
Notice that in generic type definition, one can use <code>A&gt;:B</code> and
<code>A&lt;:B</code> to add constraint to the meta type.
</p>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Pattern match</h2>
<div class="outline-text-2" id="text-3">
<p>
Case class enables you to make classes with different parameters
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">abstract</span> <span style="color: #859900;">class</span> <span style="color: #268bd2;">CodeTree</span>&#57344;&#57345;&#57345;
<span style="color: #859900;">case</span> <span style="color: #859900;">class</span> Fork(left: CodeTree, right: CodeTree, chars: List[Char], weight: Int) <span style="color: #859900;">extends</span> <span style="color: #268bd2;">CodeTree</span>&#57344;&#57345;
<span style="color: #859900;">case</span> <span style="color: #859900;">class</span> Leaf(<span style="color: #268bd2;">char</span>: Char, weight: Int) <span style="color: #859900;">extends</span> <span style="color: #268bd2;">CodeTree</span>&#57344;&#57345;&#57345;
</pre>
</div>
<p>
For the classes listed above, you cannot directly access to any
paramter (field) of <code>Fork</code> or <code>Leaf</code>. You have to use <code>case
   Fork(a,b,_,_)</code> to access to the paramters.
</p>

<p>
<code>case</code> match can also be used in lambda function as a short
version.
</p>
<div class="org-src-container">

<pre class="src src-java">List.map(p =&gt; p._1 * p._2)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
List.map({<span style="color: #859900;">case</span> (x,y) =&gt; x * y})&#57344;&#57345;&#57345;
<span style="color: #93a1a1; font-style: italic;">//</span><span style="color: #93a1a1; font-style: italic;">List.map{case (x,y) =&gt; x * y} also works</span>&#57344;&#57345;&#57345;
</pre>
</div>

<p>
Option calsss used for the condition that the returned type can be
empty/null, etc.
</p>

<p>
If you want to match a variable in context, you have to weither use
a capitalized variable name <code>Variable</code> or wrap it by backticks
<code>`variable`</code>.
</p>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Collections</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>List is a chain while Vector is a tree that each node is an array
that contains 32 elements. Vector groups in depth slowly
<code>log_{32}(N)</code>. Important functions: <code>map</code>, <code>filter</code>,
<code>reduceRight</code>, <code>reduceLeft</code>, <code>foldRight</code>, <code>foldLeft</code>, <code>flatten</code>,
<code>flatMap</code>, <code>take</code>, <code>drop</code>, <code>takeWhile, =dropWhile</code>, <code>span</code>,
<code>group</code>, <code>groupBy</code>.

<p>
Sequence as parameter list is represented by <code>this(par: T*)</code>.
</p>
</li>
<li>Map.
<ul class="org-ul">
<li>The <code>+</code> and <code>++</code> operations overwrite the existing key.
</li>
<li>Initialized by <code>Map(k1-&gt;v1, k2-&gt;v2, k3-&gt;v3)</code>
</li>

<li>Set default value by <code>withDefaultValue</code>, this function returns
a new map (everything in this course are immutable).
</li>
</ul>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Stream, Iterator, Generator and <code>lazy</code></h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Stream</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Stream, acts like sequence, but it does not evaluate until be
called. It can be used to ignore unecessary computation and coding
infinite concepts.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">fibo</span>:Stream[Int] = 1 #:: 1 #:: fibo.zip(fibo.tail).map(x=&gt;x._1+x._2)&#57344;&#57345;
println(fibo.take(10).toList)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
def from(n: Int): Stream[Int] = n #:: from(n+1) <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">infinite integer stream starts from n</span>&#57344;&#57345;
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">recursive stream</span>&#57344;&#57345;&#57345;
def sieve(s: Stream[Int]): Stream[Int] =&#57344;&#57345;&#57345;
   s.head #:: sieve(s.<span style="color: #268bd2;">tail</span> <span style="color: #6c71c4;">filter</span> (_ % s.head !=0)) <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">stream of primes &#36136;&#25968;</span>&#57344;&#57345;
&#57344;&#57345;&#57345;
val primes = sieve(from(2))&#57344;&#57345;&#57345;
primes.take(10).toList <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">the first 10 primes starts from 2.</span>&#57344;&#57345;&#57345;
</pre>
</div>

<p>
Three ways of using stream
</p>
<ul class="org-ul">
<li>Transform from other collections, then you use functions like
map, etc. to generate new stream.
</li>
<li><code>elem #:: Stream</code>
</li>
<li>Transform from iterator, use for loop to create an iterator with
what you want and then convert it into a stream.
</li>
</ul>

<p>
Because Stream has consistent API as List/Seq/Vector, you can use
it as if you have a collection that contains everything.
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Iterator</h3>
<div class="outline-text-3" id="text-5-2">
<p>
The difference between stream and iterator is stream memories the
values while iterator doesn&#8217;t.
</p>

<p>
Iterator can be used in for-expression. For-expression can
also use <b>pattern match</b>.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">for</span>{ pattern(x) &lt;- seq; pattern2(y) = x(k); ...} yield ...&#57344;&#57345;&#57345;
</pre>
</div>
<p>
As show in the example above, you can apply pattern to loop on the
elements of sequence, you can even add some simple statements in
the for-expression. It is equivalent to:
</p>
<div class="org-src-container">

<pre class="src src-java">seq.withFilter({<span style="color: #859900;">case</span> pattern(x) =&gt; <span style="color: #268bd2;">true</span>; <span style="color: #859900;">case</span> _ =&gt; <span style="color: #268bd2;">false</span>})&#57344;&#57345;&#57345;
   .map({<span style="color: #859900;">case</span> pattern(x) =&gt; x(k)})&#57344;&#57345;&#57345;
   .withFilter({<span style="color: #859900;">case</span> pattern2(y) =&gt; <span style="color: #268bd2;">true</span>; <span style="color: #859900;">case</span> _ =&gt; <span style="color: #268bd2;">false</span>})&#57344;&#57345;&#57345;
   .map({<span style="color: #859900;">case</span> pattern2(y) =&gt; y})&#57344;&#57345;&#57345;
   ...&#57344;&#57345;&#57345;
</pre>
</div>
<p>
The function <code>withFilter</code> returns a <code>FilterMonadic</code>, which
provides four functions <code>flatMap</code>, <code>map</code>, <code>foreach</code>,
<code>withFilter</code>. It works like list of call backs in programming
point of view.
From wikipedia:
/In functional programming, a monad is a structure that represents computations defined as sequences of steps: a type with a monad structure defines what it means to chain operations, or nest functions of that type together.
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> <code>lazy val</code></h3>
<div class="outline-text-3" id="text-5-3">
<p>
<code>lazy val</code> is only evaluated once when called. You can also define
a lazy parameter by <code>def myFUnc[T](param: =&gt; T)</code>, then the
parameter will be evaluated when it is called in <code>myFunc</code> if the
param is returned by an expression/function.
</p>
</div>
</div>
</div>

]]></content>
</entry>

</feed>
