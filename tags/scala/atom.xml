<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title><![CDATA[Tag: Scala | 记往开来]]></title>
<link href="http://xiaoliuai.github.io/tags/scala/atom.xml" rel="self"/>
<link href="http://xiaoliuai.github.io/"/>
<updated>2015-03-01T00:54:50+01:00</updated>
<id>http://xiaoliuai.github.io/</id>
<author>
<name><![CDATA[Xiao Liu]]></name>

</author>
<generator uri="http://octopress.org/">Octopress</generator>

<entry>
<title type="html"><![CDATA[Principles of Reactive Programming on Coursera]]></title>
<link href="http://xiaoliuai.github.io/blog/2015-02-28-principles-of-reactive-programming-on-coursera.html"/>
<updated>2015-02-28T00:00:00+01:00</updated>
<id>http://xiaoliuai.github.io/blog/principles-of-reactive-programming-on-coursera</id>
<content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Monad</a></li>
<li><a href="#sec-2">2. ScalaCheck &amp; ScalaTest</a>
<ul>
<li><a href="#sec-2-1">2.1. Tutorial of ScalaCheck</a></li>
<li><a href="#sec-2-2">2.2. ScalaTest</a></li>
</ul>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><a href="xiaoliuai.github.io/tags/scala/atom.xml"><span class="section-number-2">1</span> Monad</a></h2>
<div class="outline-text-2" id="text-1">
<p>
Honestly, I don&#8217;t understand it. But I collect my thoughts about it
here. First, the monda is used to chain operations and if the first
(preceding) operation fails, the whole chain stops. An example that
I understand is the usage of for-expression with pattern match. If
the pattern matches, go next operation, else skip this element.
</p>

<p>
Another point of view is about the unit operation. A monad flatMap
with its unit operation will return the monad itself.
</p>

<p>
<b>My conclusion</b>:
</p>

<p>
A monad is a container that supports operation chain and follows
the monad laws. The basic operations of this container are
<code>flatMap</code> and <code>unit</code>, where <code>flatMap</code> actually accepts a function
that maps each element to a container, then binds these containers
together; <code>unit</code> returns a container given an element. Monad laws
guarantee the reliability of operation chain on these contains.
</p>

<p>
Monad seems like a design pattern that enables the operation chain
along with pattern match in functional programming. Because
<code>flatMap</code> chain with different functions is equivalent to nested
<code>flatMap</code>, the for-expression is a syntax sugar based on <code>flatMap</code>
chain. The advantage of this design pattern is avoding side effect.
</p>

<p>
Generator is created by <code>yield</code> as well as
<b>for-expression</b>. Pay attention, there is no generator
class/type/trait. The genrator created through for-expression has
the same type of the sequence/iterator/stream used in
for-expression. That proves the for-expression is a syntax sugar of
monad types. So, guess what will happen when we create a
for-expression using both <b>list</b> and <b>stream</b>?
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">fibo</span>:Stream[Int] = 1 #:: 1 #:: fibo.zip(fibo.tail).map(x=&gt;x._1+x._2)
val l = List(1,2,3,4,5)
val lsg = <span style="color: #859900;">for</span>{x &lt;- l; fib &lt;- fibo} yield (x,fib)<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">infinite loop, crash the software/your machine</span>
val slg = <span style="color: #859900;">for</span>{fib &lt;- fibo; x &lt;- l} yield (x,fib)<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">return a stream</span>
</pre>
</div>
<p>
Following the definition of Monad, the first mixture <code>lsg</code> actually
makes <code>l flatMap (x =&gt; fibo)</code>, which returns a List that tries to
expand infinite stream <code>fibo</code>, hence block your machine. The second
mixture <code>slg</code> returns a Stream that expand the list <code>l</code>, hence,
works well. Besides, I have to clarify one thing: different monads
demonstrated above all accept <code>GenTraversableOnce</code> as parameter and
return monad of their own type. That is why they can be mixed
together and the first expression decides the type of the final
output of for-expression.
</p>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> ScalaCheck &amp; ScalaTest</h2>
<div class="outline-text-2" id="text-2">
<p>
It is a tool for property-based testing for scala. It has <b>NO</b>
external dependencies and integrated in the test frameworks
<b>ScalaTest</b>. It can also be used standalone, with its built-in test
runner.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Tutorial of ScalaCheck</h3>
<div class="outline-text-3" id="text-2-1">
<p>
First, create a class that extends class
<code>org.scalacheck.Properties</code> with the name of data object that you
want to test. It is used for the library to generate test data to
test your algorithm.
</p>

<p>
Second, create test case by
</p>
<div class="org-src-container">

<pre class="src src-java">property(<span style="color: #2aa198;">"NAME_OF_FUNCTION"</span>) = forAll{
    CONTAINER_OF_DATA =&gt; TEST_CASE_WITH_TARGET_FUNCTION
}
</pre>
</div>
<p>
<code>forAll</code> is the function <code>org.scalacheck.Prop.forAll</code>.
</p>

<p>
Third, to run the tests, you can put the properties in
<code>src/test/scala</code> then use test task to check them.
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> ScalaTest</h3>
<div class="outline-text-3" id="text-2-2">
<p>
In the example provided by the oneline course, they used <b>JUnit</b>,
<b>ScalaTest</b> and <b>ScalaCheck</b> together, which is much more complext
than the tutorial. In their example, the class of <code>Properties</code> is
in <code>src/main/scala</code> and is called by another class defined under
<code>src/test/scala</code>. In the class under test folder, many instances
of the <code>Properties</code> class are created to check different children
classes of the target class.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">@RunWith</span>(<span style="color: #268bd2;">classOf</span>[JUnitRunner])
<span style="color: #859900;">class</span> <span style="color: #268bd2;">QuickCheckSuite</span> <span style="color: #859900;">extends</span> <span style="color: #268bd2;">FunSuite</span> with Checkers {
  <span style="color: #268bd2;">def</span> <span style="color: #b58900;">checkBogus</span>(p: Prop) {
    <span style="color: #268bd2;">var</span> <span style="color: #6c71c4;">ok</span> = <span style="color: #268bd2;">false</span>
    <span style="color: #859900;">try</span> {
      check(p)
    } <span style="color: #859900;">catch</span> {
      <span style="color: #859900;">case</span> e: TestFailedException =&gt;
        ok = <span style="color: #268bd2;">true</span>
    }
    assert(ok, <span style="color: #2aa198;">"A bogus heap should NOT satisfy all properties. Try to find the bug!"</span>)
  }

  <span style="color: #b58900;">test</span>(<span style="color: #2aa198;">"Binomial heap satisfies properties."</span>) {
    check(<span style="color: #859900;">new</span> <span style="color: #268bd2;">QuickCheckHeap</span> with BinomialHeap)
  }

  <span style="color: #b58900;">test</span>(<span style="color: #2aa198;">"Bogus (1) binomial heap does not satisfy properties."</span>) {
    checkBogus(<span style="color: #859900;">new</span> <span style="color: #268bd2;">QuickCheckHeap</span> with Bogus1BinomialHeap)
  }

  <span style="color: #b58900;">test</span>(<span style="color: #2aa198;">"Bogus (2) binomial heap does not satisfy properties."</span>) {
    checkBogus(<span style="color: #859900;">new</span> <span style="color: #268bd2;">QuickCheckHeap</span> with Bogus2BinomialHeap)
  }

  <span style="color: #b58900;">test</span>(<span style="color: #2aa198;">"Bogus (3) binomial heap does not satisfy properties."</span>) {
    checkBogus(<span style="color: #859900;">new</span> <span style="color: #268bd2;">QuickCheckHeap</span> with Bogus3BinomialHeap)
  }

  <span style="color: #b58900;">test</span>(<span style="color: #2aa198;">"Bogus (4) binomial heap does not satisfy properties."</span>) {
    checkBogus(<span style="color: #859900;">new</span> <span style="color: #268bd2;">QuickCheckHeap</span> with Bogus4BinomialHeap)
  }

  <span style="color: #b58900;">test</span>(<span style="color: #2aa198;">"Bogus (5) binomial heap does not satisfy properties."</span>) {
    checkBogus(<span style="color: #859900;">new</span> <span style="color: #268bd2;">QuickCheckHeap</span> with Bogus5BinomialHeap)
  }
}
</pre>
</div>
<ul class="org-ul">
<li>This class uses the junit framework for unittest. JUnit will
invoke the class with <code>@RunWith</code> annotation (extend by type
hierarchies) to run the tests. The annotation parameter in the
example is a class of the type <code>JUnitRunner</code>. In fact, any class
extends <code>Runner</code> is acceptabel. Notice that function <code>classOf</code>
acts the same as <code>obj.getClass()</code>.
</li>
<li>The annotation uses class of <code>JUnitRunner</code> as parameter. This
class is provided by scala-test framework.
</li>
<li>It is mentioned on <a href="http://www.scalatest.org/user_guide/using_the_scalatest_maven_plugin">ScalaTest Maven Plugin</a> that this annotaiton
is necessary to run the test without this plugin. So you can run
tests without this annotation by using this plugin.
<ul class="org-ul">
<li><b>Maven</b> Running tests with command <code>mvn test</code>. In fact, you
<b>cannot</b> run the tests with the example above. <b>Solution</b> is
to change the name <code>QuickCheckSuite</code> to <code>QuickCheckSuiteTest</code>
or <code>TestQuickCheckSuite</code> or <code>QuickCheckSuiteTestCase</code> to run
the tests. Even I did not explicitly specify plugin
<code>surefire</code>, maven uses this plugin to run test with my
configuration. By default, maven following name convertions
when looking for tests to run. So I have to change the name or
modify the <code>surefire</code> configuration to apply new name
convertion rules.
</li>
<li><b>ScalaTest</b> plugin. <b>TODO</b>
</li>
</ul>
</li>
<li><code>org.scalatest.FunSuite</code> and <code>org.scalatest.prop.Checkers</code>.
<b>TODO</b>
</li>
</ul>
</div>
</div>
</div>

]]></content>
</entry>

<entry>
<title type="html"><![CDATA[Functional Programming on Coursera]]></title>
<link href="http://xiaoliuai.github.io/blog/2015-02-28-functional-programming-on-coursera.html"/>
<updated>2015-02-28T00:00:00+01:00</updated>
<id>http://xiaoliuai.github.io/blog/functional-programming-on-coursera</id>
<content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Lambda function</a></li>
<li><a href="#sec-2">2. Type hierachy</a></li>
<li><a href="#sec-3">3. Pattern match</a></li>
<li><a href="#sec-4">4. Implicit</a>
<ul>
<li><a href="#sec-4-1">4.1. Implicit Parameter</a></li>
<li><a href="#sec-4-2">4.2. Implicit Function</a></li>
<li><a href="#sec-4-3">4.3. Implicit Class</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Collections</a></li>
<li><a href="#sec-6">6. Stream, Iterator, Generator and <code>lazy</code></a>
<ul>
<li><a href="#sec-6-1">6.1. Stream</a></li>
<li><a href="#sec-6-2">6.2. Iterator</a></li>
<li><a href="#sec-6-3">6.3. <code>lazy val</code></a></li>
</ul>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><a href="xiaoliuai.github.io/tags/scala/atom.xml"><span class="section-number-2">1</span> Lambda function</a></h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>function is value,
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">f</span> = (x:Int) =&gt; x*x
</pre>
</div>
<p>
One difference between <code>def f = ...</code> and <code>val f = ...</code> is: <code>def</code>
is evaluated on call and returns a new function instance every
time.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">val</span> <span style="color: #b58900;">test</span>: () =&gt; Int = {
    println(<span style="color: #2aa198;">"val"</span>)
    val r = <span style="color: #268bd2;">util</span>.Random.nextInt
    () =&gt; r
}
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">returns the same result every time you call test(),</span>
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">"val" will be printed after definition</span>

<span style="color: #268bd2;">def</span> <span style="color: #b58900;">test</span>: () =&gt; Int = {
    println(<span style="color: #2aa198;">"def"</span>)
    val r = <span style="color: #268bd2;">util</span>.Random.nextInt
    () =&gt; r
}
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">returns the difference results every time you call test(),</span>
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">"def" will be printed every time you call it.</span>

<span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">tt</span> = test
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">acts like the first example</span>

val test = () =&gt; <span style="color: #268bd2;">util</span>.Random.nextInt
def test = () =&gt; <span style="color: #268bd2;">util</span>.Random.nextInt
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">they are the same from behavior, you have to call the function by test()</span>
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">the def declaration actually defined a function that returns a function.</span>
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">if you type test without parenthesis, you will receive a function value.</span>

def test = <span style="color: #268bd2;">util</span>.Random.nextInt
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">this line directly assign the test function to the nextInt function,</span>
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">you can call the function directly by name without the parenthesis</span>
</pre>
</div>
<p>
method/expression starts by <code>def</code> will be evaluated when you call
<code>obj.f</code> while those starts by <code>val</code> will be evaluated
once. In addition, if you declare a <code>val</code> that assigns to <code>def</code>,
the <code>def</code> will be evaluated immediately, and the new <code>val</code> acts
like the first case in the examples above.
</p>
</li>
<li>Abbreviation:
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">l</span> = List(1,2,3)
l.map((x) =&gt; x*x)
l.map( x =&gt; x*x) <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">ignore the parenthese</span>
l.map( _ % 2 == 0) <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">ignore the parameter, using the placeholder for expression</span>
l.map(f(_)) <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">using the placeholder for function</span>
l.map(f) <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">ignore the placeholder for function</span>
</pre>
</div>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Type hierachy</h2>
<div class="outline-text-2" id="text-2">
<p>
abstract class is like Java, trait is like interface in
Java. However, trait can have parameters and defined methods. In
addition, trait is not abstract class since it cannot has
constructors.
</p>
<ul class="org-ul">
<li>Logical problem: is List&lt;Parent&gt; the parent of List&lt;Childe&gt;?

<p>
It is not true for mutable collection.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">var</span> <span style="color: #6c71c4;">s</span> = <span style="color: #859900;">new</span> <span style="color: #268bd2;">Array</span>[Man](<span style="color: #859900;">new</span> <span style="color: #268bd2;">Man</span>())
var t:Array[Human] = s
t[0] = <span style="color: #859900;">new</span> <span style="color: #268bd2;">Woman</span>()
var m:Man = s[0]<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">what is it? man or woman?</span>
</pre>
</div>
<p>
But we can use imutable collection.
</p>
</li>

<li>Covariant, Contvariant, Invariant
<ul class="org-ul">
<li>Covariant: defined by Class&lt;+T&gt;, Class&lt;Parent&gt; is the parent of
Class&lt;Child&gt;
</li>

<li>Contvariant: defined by Class&lt;-T&gt;, Function&lt;Parent&gt; is the
child of Function&lt;Child&gt;
</li>
</ul>
<p>
The principle is: child type can do anything that can be done by
parent type.
</p>
</li>

<li>Check Rules and Boundary

<p>
To avoid conflict, the compile force the +T can only be used for
returned type, the -T can only be used for argument type. A
method to by pass this problem is using boundary.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">class</span> <span style="color: #268bd2;">List</span>&lt;+T&gt;{
     <span style="color: #268bd2;">def</span> <span style="color: #6c71c4;">prepend</span>[U &gt;: T](<span style="color: #268bd2;">U</span> <span style="color: #6c71c4;">elem</span>)
}
</pre>
</div>
<p>
Notice that in generic type definition, one can use <code>A&gt;:B</code> and
<code>A&lt;:B</code> to add constraint to the meta type.
</p>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Pattern match</h2>
<div class="outline-text-2" id="text-3">
<p>
Case class enables you to make classes with different parameters
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">abstract</span> <span style="color: #859900;">class</span> <span style="color: #268bd2;">CodeTree</span>
<span style="color: #859900;">case</span> <span style="color: #859900;">class</span> Fork(left: CodeTree, right: CodeTree, chars: List[Char], weight: Int) <span style="color: #859900;">extends</span> <span style="color: #268bd2;">CodeTree</span>
<span style="color: #859900;">case</span> <span style="color: #859900;">class</span> Leaf(<span style="color: #268bd2;">char</span>: Char, weight: Int) <span style="color: #859900;">extends</span> <span style="color: #268bd2;">CodeTree</span>
</pre>
</div>
<p>
For the classes listed above, you cannot directly access to any
paramter (field) of <code>Fork</code> or <code>Leaf</code>. You have to use <code>case
   Fork(a,b,_,_)</code> to access to the paramters.
</p>

<p>
<code>case</code> match can also be used in lambda function as a short
version.
</p>
<div class="org-src-container">

<pre class="src src-java">List.map(p =&gt; p._1 * p._2)

List.map({<span style="color: #859900;">case</span> (x,y) =&gt; x * y})
<span style="color: #93a1a1; font-style: italic;">//</span><span style="color: #93a1a1; font-style: italic;">List.map{case (x,y) =&gt; x * y} also works</span>
</pre>
</div>

<p>
Option calsss used for the condition that the returned type can be
empty/null, etc.
</p>

<p>
If you want to match a variable in context, you have to weither use
a capitalized variable name <code>Variable</code> or wrap it by backticks
<code>`variable`</code>.
</p>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Implicit</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Implicit Parameter</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Implicit parameter looks similar to default parameter, but their
principles are completely different. Default parameter has a
default value to be used when the parameter is not given. Implicit
parameter will search the context to get an appropriate
value/variable as parameter.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">abstract</span> <span style="color: #859900;">class</span> <span style="color: #268bd2;">Logger</span> {<span style="color: #268bd2;">def</span> <span style="color: #b58900;">log</span>(s: String)}
<span style="color: #859900;">class</span> <span style="color: #268bd2;">FileLogger</span> <span style="color: #859900;">extends</span> <span style="color: #268bd2;">Logger</span> {
  <span style="color: #268bd2;">def</span> <span style="color: #b58900;">log</span>(s: String) {println(<span style="color: #2aa198;">"Log in file: "</span> + s)}
}
<span style="color: #859900;">class</span> <span style="color: #268bd2;">StdoutLogger</span> <span style="color: #859900;">extends</span> <span style="color: #268bd2;">Logger</span> {
  <span style="color: #268bd2;">def</span> <span style="color: #b58900;">log</span>(s: String) {println(<span style="color: #2aa198;">"Stdout: "</span> + s)}
}

<span style="color: #268bd2;">def</span> <span style="color: #b58900;">Add</span>(a: Int, b: Int)(<span style="color: #268bd2;">implicit</span> <span style="color: #6c71c4;">logger</span>: Logger) {
  <span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">sum</span> = a + b
  logger.log(<span style="color: #2aa198;">"%d + %d = %d"</span>.format(a, b, sum ))
}

<span style="color: #268bd2;">implicit</span> <span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">log</span> = <span style="color: #859900;">new</span> <span style="color: #268bd2;">FileLogger</span>

Add(1,2)
Add(2,3)(<span style="color: #859900;">new</span> <span style="color: #268bd2;">StdoutLogger</span>) <span style="color: #93a1a1; font-style: italic;">//</span><span style="color: #93a1a1; font-style: italic;">you may do it explicitly</span>
</pre>
</div>
<p>
If there is no <code>implicit val log = new FileLogger</code>, the compiler
will report error. <i>It is similar to injection by type.</i>
</p>

<p>
Question: what if there are two possible candidates in the context?
</p>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Implicit Function</h3>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Implicit Class</h3>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Collections</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>List is a chain while Vector is a tree that each node is an array
that contains 32 elements. Vector groups in depth slowly
<code>log_{32}(N)</code>. Important functions: <code>map</code>, <code>filter</code>,
<code>reduceRight</code>, <code>reduceLeft</code>, <code>foldRight</code>, <code>foldLeft</code>, <code>flatten</code>,
<code>flatMap</code>, <code>take</code>, <code>drop</code>, <code>takeWhile, =dropWhile</code>, <code>span</code>,
<code>group</code>, <code>groupBy</code>.

<p>
Sequence as parameter list is represented by <code>this(par: T*)</code>.
</p>
</li>
<li>Map.
<ul class="org-ul">
<li>The <code>+</code> and <code>++</code> operations overwrite the existing key.
</li>
<li>Initialized by <code>Map(k1-&gt;v1, k2-&gt;v2, k3-&gt;v3)</code>
</li>

<li>Set default value by <code>withDefaultValue</code>, this function returns
a new map (everything in this course are immutable).
</li>
</ul>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Stream, Iterator, Generator and <code>lazy</code></h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Stream</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Stream, acts like sequence, but it does not evaluate until be
called. It can be used to ignore unecessary computation and coding
infinite concepts.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2;">val</span> <span style="color: #6c71c4;">fibo</span>:Stream[Int] = 1 #:: 1 #:: fibo.zip(fibo.tail).map(x=&gt;x._1+x._2)
println(fibo.take(10).toList)

def from(n: Int): Stream[Int] = n #:: from(n+1) <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">infinite integer stream starts from n</span>
<span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">recursive stream</span>
def sieve(s: Stream[Int]): Stream[Int] =
   s.head #:: sieve(s.<span style="color: #268bd2;">tail</span> <span style="color: #6c71c4;">filter</span> (_ % s.head !=0)) <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">stream of primes &#36136;&#25968;</span>

val primes = sieve(from(2))
primes.take(10).toList <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">the first 10 primes starts from 2.</span>
</pre>
</div>

<p>
Three ways of using stream
</p>
<ul class="org-ul">
<li>Transform from other collections, then you use functions like
map, etc. to generate new stream.
</li>
<li><code>elem #:: Stream</code>
</li>
<li>Transform from iterator, use for loop to create an iterator with
what you want and then convert it into a stream.
</li>
</ul>

<p>
Because Stream has consistent API as List/Seq/Vector, you can use
it as if you have a collection that contains everything.
</p>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> Iterator</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The difference between stream and iterator is stream memories the
values while iterator doesn&#8217;t.
</p>

<p>
Iterator can be used in for-expression. For-expression can
also use <b>pattern match</b>.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900;">for</span>{ pattern(x) &lt;- seq; pattern2(y) = x(k); ...} yield ...
</pre>
</div>
<p>
As show in the example above, you can apply pattern to loop on the
elements of sequence, you can even add some simple statements in
the for-expression. It is equivalent to:
</p>
<div class="org-src-container">

<pre class="src src-java">seq.withFilter({<span style="color: #859900;">case</span> pattern(x) =&gt; <span style="color: #268bd2;">true</span>; <span style="color: #859900;">case</span> _ =&gt; <span style="color: #268bd2;">false</span>})
   .map({<span style="color: #859900;">case</span> pattern(x) =&gt; x(k)})
   .withFilter({<span style="color: #859900;">case</span> pattern2(y) =&gt; <span style="color: #268bd2;">true</span>; <span style="color: #859900;">case</span> _ =&gt; <span style="color: #268bd2;">false</span>})
   .map({<span style="color: #859900;">case</span> pattern2(y) =&gt; y})
   ...
</pre>
</div>
<p>
The function <code>withFilter</code> returns a <code>FilterMonadic</code>, which
provides four functions <code>flatMap</code>, <code>map</code>, <code>foreach</code>,
<code>withFilter</code>. It works like list of call backs in programming
point of view.
From wikipedia:
/In functional programming, a monad is a structure that represents computations defined as sequences of steps: a type with a monad structure defines what it means to chain operations, or nest functions of that type together.
</p>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> <code>lazy val</code></h3>
<div class="outline-text-3" id="text-6-3">
<p>
<code>lazy val</code> is only evaluated once when called. You can also define
a lazy parameter by <code>def myFUnc[T](param: =&gt; T)</code>, then the
parameter will be evaluated when it is called in <code>myFunc</code> if the
param is returned by an expression/function.
</p>
</div>
</div>
</div>

]]></content>
</entry>

</feed>
